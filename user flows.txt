user flows.


base:
ship ~zod exists 
ship ~nus exists

1. ship ~zod creates library X in its local graph store

x. ~zod wishes to add a book to his own library
	a. zod sends a poke to his own proxy to add the book
	   the proxy handles it, poking the local graph store.


y. ~nus wishes to subscribe to all books that it is allowed to see from ~zod's library X
	a. ~nus sends a well formed subscription request (watch) from his proxy to ~zod's proxy on path /updates/~nus
	b. now, any and all graph updates that ~nus should hear about will flow into it's +on-agent arm, with the path /updates/~nus
	c. ~zod must send any and all updates that ~nus must see from his proxy to ~nus's proxy
		- to do this, ~zod's proxy subscribes to it's own graph store for all updates. when it receives a graph-update from graph store,
		  it must send all ships that need to know about it the update by generating cards.
		  to construct a list of all ships that should know (and thus all paths to send the update cards on),
		  first get the prim associated with the resource of the update.
		  then, get the 0th index fragment of the update, i.e. what root node, or book, is being modified.
		  using his index fragment, key into the prim to access the list of ships that deserve to know about the update.
		  now, construct list of cards necessary to update all subscribers with the given update and deserving ships

z. ~nus wishes to comment on a book in library X on ~zod's ship.
	a. ~nus pokes ~zod's library proxy with an %library-proxy-action+[%add-comment resource top comment] poke.
	b. in ~zod's proxy, specifically in the +on-poke arm, ~zod receives the poke
		- first he !< devases the action. 
		- then, he gets the desired resource for the action
		- then, he gets the prim for the resource from permissions
		- then, using the the desired book index fragment as a key, he gets the set of ships allowed for that book
		- an assertion is made that the src.bowl, i.e. ~nus, is in the set of ships allowed
		- then, a graph update representing the comment is constructed (using a lib function) and the local graph store is poked with it.

j. a comment by ~zod is added to book with index frag 3. ~nus, who has permissions to book with index fragment 3, should recceive this.
	a. in ~zod's on-agent, an update comes in of %add-nodes to book 3. this must be propagated to all subscibers to book 3.
	b. first, we get the resource that this was performed on.
	c. then, we get the set of ships that need to know about this by extracting it out frmo the permissions + prim. in this case, it is just ~nus
	d. then, we generate a card that sends a subcription update on path /updates/~nus, ~nus' library proxy will reseceive the update on his +on-agent arm
	e. once he receives a graph update in his on-agent arm, he will apply it to his local graph store.
		conundrum: how do you detect between a graph update frmo yuor local grpah store that needs to go outbound,
		vs. a grap update that came frm a proxy that must come inbound and be applied locally.
		because if yo udon it will get confused or smtn. imgagine you add yourself to the permissinos set. then youl'' get a subscription loop. or 


DISALLOW proxy subscribing to itself

when i get a graph update from my local graph store (in on agent)
ONLY Send out updates for resources that you own
input: flat list of graph-store updates
decide (and create list of) which `update:store`s actually make it to the subscriber: could be all or some or only one  (!!)
output: flat list of updates now associated with set of ships supposed to receive

when i get foreign update in on-agent (i.e. from another proxy)
do some permissioning / sanity checks?: if they own it, you trust them, no need for sanity checks cause you don't have any info to do so
make sure the update is for a resource that src owns (chekc for imposter basiiccaly)
then apply update / poke local graph store




loop thru updates
alternative: build a list of (map ship cards-to-send)



